{{- if eq .chezmoi.os "windows" -}}
# PowerShell Profile - Managed by chezmoi
# Last updated: {{ now | date "2006-01-02" }}

# Suppress non-fatal GetHistoryItems errors from Starship/PSReadLine
$global:ErrorActionPreference = 'SilentlyContinue'

# XDG Base Directory specification
$global:ErrorActionPreference = 'SilentlyContinue'

# XDG Base Directory specification
# Ensure these are always set (even if bootstrap didn't run)
if (-not $env:XDG_CONFIG_HOME) { $env:XDG_CONFIG_HOME = "$HOME\.config" }
if (-not $env:XDG_DATA_HOME) { $env:XDG_DATA_HOME = "$HOME\.local\share" }
if (-not $env:XDG_STATE_HOME) { $env:XDG_STATE_HOME = "$HOME\.local\state" }
if (-not $env:XDG_CACHE_HOME) { $env:XDG_CACHE_HOME = "$HOME\.cache" }

# XDG-compliant tool configurations
$env:LESSHISTFILE = "$env:XDG_STATE_HOME\less\history"
$env:PYTHON_HISTORY = "$env:XDG_STATE_HOME\python\history"

# Ensure XDG state directories for tools exist
$toolStateDirs = @(
    "$env:XDG_STATE_HOME\less",
    "$env:XDG_STATE_HOME\python"
)
foreach ($dir in $toolStateDirs) {
    if (-not (Test-Path $dir)) {
        New-Item -ItemType Directory -Path $dir -Force | Out-Null
    }
}

# PSReadLine configuration - load BEFORE Starship to avoid GetHistoryItems errors
if (Get-Module -ListAvailable -Name PSReadLine) {
    Import-Module PSReadLine
    
    # Vi mode
    Set-PSReadLineOption -EditMode Vi
    
    # History settings
    Set-PSReadLineOption -HistorySearchCursorMovesToEnd
    Set-PSReadLineOption -HistorySaveStyle SaveIncrementally
    Set-PSReadLineOption -MaximumHistoryCount 10000
    
    # Predictive IntelliSense
    Set-PSReadLineOption -PredictionSource History
    Set-PSReadLineOption -PredictionViewStyle ListView
    
    # Starship uses 2-line prompt - set ExtraPromptLineCount for proper PSFzf rendering
    Set-PSReadLineOption -ExtraPromptLineCount 1
    
    # Key bindings
    Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward
    Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward
    Set-PSReadLineKeyHandler -Key Tab -Function MenuComplete
    Set-PSReadLineKeyHandler -Key Ctrl+d -Function DeleteCharOrExit
}

# PSCompletions (completion manager) - must load AFTER PSReadLine key bindings
# as it overrides Tab with its own custom menu
if (Get-Module -ListAvailable -Name PSCompletions) {
    Import-Module PSCompletions
    $PSCompletions.init_data()
    $PSCompletions.handle_completion()
}

# Initialize Starship prompt
if (Get-Command starship -ErrorAction SilentlyContinue) {
    Invoke-Expression (&starship init powershell)
}

# Initialize Mise (tool version manager)
if (Get-Command mise -ErrorAction SilentlyContinue) {
    Invoke-Expression (& mise activate pwsh | Out-String)
}

# WSL Tab Completion
if (Get-Module -ListAvailable -Name WSLTabCompletion) {
    Import-Module WSLTabCompletion
}

# Import GamePerformanceOptimizer
if (Get-Module -ListAvailable -Name GamePerformanceOptimizer) {
    Import-Module GamePerformanceOptimizer
}

# Source all modular scripts from Scripts directory
$scriptsDir = Join-Path (Split-Path $PROFILE) "Scripts"
if (Test-Path $scriptsDir) {
    Get-ChildItem "$scriptsDir\*.ps1" -ErrorAction SilentlyContinue | ForEach-Object {
        Write-Verbose "Sourcing: $($_.Name)"
        . $_.FullName
    }
}


# VS Code shell integration
if ($env:TERM_PROGRAM -eq "vscode") {
    . "$(code --locate-shell-integration-path pwsh)"
}

# Set LS_COLORS using Vivid ({{ .theme }} theme)
{{- if index .package_features "vivid" }}
if (Get-Command vivid -ErrorAction SilentlyContinue) {
    $env:LS_COLORS = (vivid generate {{ .theme }})
}
{{- end }}

# Bash-style history expansion (!!, !$)
Set-PSReadLineKeyHandler -Key Spacebar -ScriptBlock {
    $line = $null
    $cursor = $null
    [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$line, [ref]$cursor)
    
    # Handle !! expansion (repeat last command)
    if ($line -match '!!') {
        $lastCommand = (Get-History -Count 1).CommandLine
        if ($lastCommand) {
            $newLine = $line -replace '!!', $lastCommand
            [Microsoft.PowerShell.PSConsoleReadLine]::Replace(0, $line.Length, $newLine)
            [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($newLine.Length)
        }
    }
    # Handle !$ expansion (last argument of last command)
    elseif ($line -match '!\$') {
        $lastCommand = (Get-History -Count 1).CommandLine
        if ($lastCommand) {
            # Get last argument (split on whitespace, take last non-empty)
            $lastArg = ($lastCommand -split '\s+' | Where-Object { $_ }) | Select-Object -Last 1
            if ($lastArg) {
                $newLine = $line -replace '!\$', $lastArg
                [Microsoft.PowerShell.PSConsoleReadLine]::Replace(0, $line.Length, $newLine)
                [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($newLine.Length)
            }
        }
    }
    
    # Insert the space
    [Microsoft.PowerShell.PSConsoleReadLine]::Insert(' ')
}

# Restore error action preference after profile loads
$global:ErrorActionPreference = 'Continue'

# 1Password SSH Agent integration
{{- if .setup_1password }}
$env:SSH_AUTH_SOCK = "\\.\pipe\openssh-ssh-agent"
{{- end }}

# Welcome message (optional - comment out if you prefer clean startup)
# Write-Host "PowerShell $($PSVersionTable.PSVersion) - Welcome, {{ .name }}!" -ForegroundColor Cyan
{{- end -}}
