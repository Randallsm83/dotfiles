{{- if eq .chezmoi.os "windows" -}}
# PowerShell Profile - Managed by chezmoi
# Last updated: {{ now | date "2006-01-02" }}

# XDG Base Directory specification
# Ensure these are always set (even if bootstrap didn't run)
if (-not $env:XDG_CONFIG_HOME) { $env:XDG_CONFIG_HOME = "$HOME\.config" }
if (-not $env:XDG_DATA_HOME) { $env:XDG_DATA_HOME = "$HOME\.local\share" }
if (-not $env:XDG_STATE_HOME) { $env:XDG_STATE_HOME = "$HOME\.local\state" }
if (-not $env:XDG_CACHE_HOME) { $env:XDG_CACHE_HOME = "$HOME\.cache" }

# XDG-compliant tool configurations
$env:LESSHISTFILE = "$env:XDG_STATE_HOME\less\history"
$env:PYTHON_HISTORY = "$env:XDG_STATE_HOME\python\history"

# Ensure XDG state directories for tools exist
$toolStateDirs = @(
    "$env:XDG_STATE_HOME\less",
    "$env:XDG_STATE_HOME\python"
)
foreach ($dir in $toolStateDirs) {
    if (-not (Test-Path $dir)) {
        New-Item -ItemType Directory -Path $dir -Force | Out-Null
    }
}

# Initialize Starship prompt
Invoke-Expression (&starship init powershell)

# Initialize Mise (tool version manager)
Invoke-Expression (& mise activate pwsh | Out-String)

# Initialize Zoxide (smart cd)
Invoke-Expression (& zoxide init powershell | Out-String)

# Import GamePerformanceOptimizer module (for game security exclusions)
if (Get-Module -ListAvailable -Name GamePerformanceOptimizer) {
    Import-Module GamePerformanceOptimizer
}

# Source all modular scripts from Scripts directory
$scriptsDir = Join-Path (Split-Path $PROFILE) "Scripts"
if (Test-Path $scriptsDir) {
    Get-ChildItem "$scriptsDir\*.ps1" -ErrorAction SilentlyContinue | ForEach-Object {
        Write-Verbose "Sourcing: $($_.Name)"
        . $_.FullName
    }
}

# Source aliases and functions
$aliasesFile = Join-Path (Split-Path $PROFILE) "aliases.ps1"
$functionsFile = Join-Path (Split-Path $PROFILE) "functions.ps1"

if (Test-Path $aliasesFile) {
    . $aliasesFile
}
if (Test-Path $functionsFile) {
    . $functionsFile
}

# VS Code shell integration
if ($env:TERM_PROGRAM -eq "vscode") {
    . "$(code --locate-shell-integration-path pwsh)"
}

# Set LS_COLORS using Vivid ({{ .theme.name }} theme)
{{- if .packages.scoop | has "vivid" }}
$env:LS_COLORS = (vivid generate {{ .theme.name }})
{{- end }}

# PSReadLine configuration - Vi mode with enhanced history
if (Get-Module -ListAvailable -Name PSReadLine) {
    Import-Module PSReadLine
    
    # Vi mode
    Set-PSReadLineOption -EditMode Vi
    
    # History settings
    Set-PSReadLineOption -HistorySearchCursorMovesToEnd
    Set-PSReadLineOption -HistorySaveStyle SaveIncrementally
    Set-PSReadLineOption -MaximumHistoryCount 10000
    
    # Predictive IntelliSense
    Set-PSReadLineOption -PredictionSource History
    Set-PSReadLineOption -PredictionViewStyle ListView
    
    # Key bindings
    Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward
    Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward
    Set-PSReadLineKeyHandler -Key Tab -Function MenuComplete
    Set-PSReadLineKeyHandler -Key Ctrl+d -Function DeleteCharOrExit
}

# Bash-style history expansion (!!, !$)
Set-PSReadLineKeyHandler -Key Spacebar -ScriptBlock {
    $line = $null
    $cursor = $null
    [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$line, [ref]$cursor)
    
    # Handle !! expansion (repeat last command)
    if ($line -match '!!') {
        $lastCommand = (Get-History -Count 1).CommandLine
        if ($lastCommand) {
            $newLine = $line -replace '!!', $lastCommand
            [Microsoft.PowerShell.PSConsoleReadLine]::Replace(0, $line.Length, $newLine)
            [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($newLine.Length)
        }
    }
    # Handle !$ expansion (last argument of last command)
    elseif ($line -match '!\$') {
        $lastCommand = (Get-History -Count 1).CommandLine
        if ($lastCommand) {
            # Get last argument (split on whitespace, take last non-empty)
            $lastArg = ($lastCommand -split '\s+' | Where-Object { $_ }) | Select-Object -Last 1
            if ($lastArg) {
                $newLine = $line -replace '!\$', $lastArg
                [Microsoft.PowerShell.PSConsoleReadLine]::Replace(0, $line.Length, $newLine)
                [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($newLine.Length)
            }
        }
    }
    
    # Insert the space
    [Microsoft.PowerShell.PSConsoleReadLine]::Insert(' ')
}

# 1Password SSH Agent integration
{{- if .features.setup_1password }}
$env:SSH_AUTH_SOCK = "\\.\pipe\openssh-ssh-agent"
{{- end }}

# Welcome message (optional - comment out if you prefer clean startup)
# Write-Host "PowerShell $($PSVersionTable.PSVersion) - Welcome, {{ .user.name }}!" -ForegroundColor Cyan
{{- end -}}
