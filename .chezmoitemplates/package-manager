{{- /* Package manager abstraction */ -}}
{{- /* Usage: {{ template "package-manager" . }} */ -}}

# ============================================================================
# Package Manager Abstraction
# ============================================================================

# Package name mapping
# Maps common package names to platform-specific names
map_package_name() {
    local pkg="$1"
    local mgr="${2:-$(detect_package_manager)}"
    
    case "${pkg}:${mgr}" in
        # ripgrep variations
        ripgrep:apt) echo "ripgrep" ;;
        ripgrep:dnf) echo "ripgrep" ;;
        ripgrep:pacman) echo "ripgrep" ;;
        ripgrep:brew) echo "ripgrep" ;;
        ripgrep:cargo) echo "cargo:ripgrep" ;;
        
        # fd variations
        fd:apt) echo "fd-find" ;;
        fd:dnf) echo "fd-find" ;;
        fd:pacman) echo "fd" ;;
        fd:brew) echo "fd" ;;
        fd:cargo) echo "cargo:fd-find" ;;
        
        # bat variations
        bat:apt) echo "bat" ;;
        bat:dnf) echo "bat" ;;
        bat:pacman) echo "bat" ;;
        bat:brew) echo "bat" ;;
        bat:cargo) echo "cargo:bat" ;;
        
        # eza variations
        eza:apt) echo "eza" ;;
        eza:dnf) echo "eza" ;;
        eza:pacman) echo "eza" ;;
        eza:brew) echo "eza" ;;
        eza:cargo) echo "cargo:eza" ;;
        
        # Default: return as-is
        *) echo "${pkg}" ;;
    esac
}

# Check if package is installed
is_package_installed() {
    local pkg="$1"
    
    # Check if binary exists in PATH
    if command_exists "${pkg}"; then
        return 0
    fi
    
    # Check with mise
    if command_exists mise && mise list | grep -q "^${pkg}"; then
        return 0
    fi
    
    return 1
}

# Get installed package version
get_package_version() {
    local pkg="$1"
    
    if ! is_package_installed "${pkg}"; then
        echo "not-installed"
        return 1
    fi
    
    # Try common version flags
    if command_exists "${pkg}"; then
        "${pkg}" --version 2>/dev/null | head -1 || echo "unknown"
    else
        echo "unknown"
    fi
}

# Retry a command with exponential backoff
retry_command() {
    local max_attempts="${1:-3}"
    local delay="${2:-2}"
    local cmd="${@:3}"
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if eval "$cmd"; then
            return 0
        fi
        
        if [ $attempt -lt $max_attempts ]; then
            log_warning "Attempt $attempt failed, retrying in ${delay}s..."
            sleep "$delay"
            delay=$((delay * 2))  # Exponential backoff
        fi
        
        attempt=$((attempt + 1))
    done
    
    log_error "Command failed after $max_attempts attempts"
    return 1
}

# Check if package is available in package manager
is_package_available() {
    local pkg="$1"
    local mgr="${2:-$(detect_package_manager)}"
    
    case "${mgr}" in
        apt)
            apt-cache show "${pkg}" &>/dev/null
            ;;
        dnf|yum)
            dnf list "${pkg}" &>/dev/null 2>&1 || yum list "${pkg}" &>/dev/null 2>&1
            ;;
        pacman)
            pacman -Ss "^${pkg}$" &>/dev/null
            ;;
        brew)
            brew info "${pkg}" &>/dev/null
            ;;
        *)
            return 1
            ;;
    esac
}

# Install package via appropriate package manager
install_package() {
    local pkg="$1"
    local version="${2:-latest}"
    local mgr="${3:-auto}"
    
    log_info "Installing package: ${pkg} (version: ${version})"
    
    # Skip if already installed and version matches
    if is_package_installed "${pkg}" && [ "${version}" = "latest" ]; then
        local current_version
        current_version="$(get_package_version "${pkg}")"
        log_success "Package ${pkg} already installed (${current_version})"
        return 0
    fi
    
    # Auto-detect package manager if needed
    if [ "${mgr}" = "auto" ]; then
        mgr="$(detect_package_manager)"
    fi
    
    # Map package name to platform-specific name
    local mapped_pkg
    mapped_pkg="$(map_package_name "${pkg}" "${mgr}")"
    
    log_debug "Mapped ${pkg} to ${mapped_pkg} for ${mgr}"
    
    # Check if package is available
    if ! is_package_available "${mapped_pkg}" "${mgr}"; then
        log_warning "Package ${mapped_pkg} not found in ${mgr} repositories"
        log_info "Attempting to install via mise as fallback..."
        mgr="mise"
    fi
    
    # Install based on package manager
    local result=0
    case "${mgr}" in
        apt)
            install_package_apt "${mapped_pkg}"
            result=$?
            ;;
        dnf|yum)
            install_package_dnf "${mapped_pkg}"
            result=$?
            ;;
        pacman)
            install_package_pacman "${mapped_pkg}"
            result=$?
            ;;
        brew)
            install_package_brew "${mapped_pkg}"
            result=$?
            ;;
        cargo)
            install_package_cargo "${mapped_pkg}" "${version}"
            result=$?
            ;;
        mise)
            install_package_mise "${mapped_pkg}" "${version}"
            result=$?
            ;;
        *)
            log_error "Unsupported package manager: ${mgr}"
            return 1
            ;;
    esac
    
    if [ $result -eq 0 ]; then
        log_success "Successfully installed ${pkg}"
    else
        log_error "Failed to install ${pkg}"
    fi
    
    return $result
}

# Install via apt
install_package_apt() {
    local pkg="$1"
    
    if has_sudo; then
        # Update package cache with retry
        if ! retry_command 3 2 "sudo apt-get update -qq"; then
            log_warning "apt-get update failed, continuing anyway..."
        fi
        
        # Install with retry
        if retry_command 3 2 "sudo apt-get install -y '${pkg}' 2>&1 | tee -a '${LOG_FILE:-/dev/null}'"; then
            return 0
        else
            log_error "Failed to install ${pkg} via apt"
            return 1
        fi
    else
        log_warning "No sudo access, cannot install ${pkg} via apt"
        return 1
    fi
}

# Install via dnf
install_package_dnf() {
    local pkg="$1"
    
    if has_sudo; then
        if retry_command 3 2 "sudo dnf install -y '${pkg}' 2>&1 | tee -a '${LOG_FILE:-/dev/null}'"; then
            return 0
        else
            log_error "Failed to install ${pkg} via dnf"
            return 1
        fi
    else
        log_warning "No sudo access, cannot install ${pkg} via dnf"
        return 1
    fi
}

# Install via pacman
install_package_pacman() {
    local pkg="$1"
    
    if has_sudo; then
        execute sudo pacman -S --noconfirm "${pkg}"
    else
        log_warning "No sudo access, cannot install ${pkg} via pacman"
        return 1
    fi
}

# Install via brew
install_package_brew() {
    local pkg="$1"
    execute brew install "${pkg}"
}

# Install via cargo
install_package_cargo() {
    local pkg="$1"
    local version="$2"
    
    if ! command_exists cargo; then
        log_error "cargo not found, cannot install ${pkg}"
        return 1
    fi
    
    if [ "${version}" = "latest" ]; then
        execute cargo install "${pkg}"
    else
        execute cargo install "${pkg}" --version "${version}"
    fi
}

# Install via mise
install_package_mise() {
    local pkg="$1"
    local version="$2"
    
    if ! command_exists mise; then
        log_error "mise not found, cannot install ${pkg}"
        return 1
    fi
    
    if [ "${version}" = "latest" ]; then
        execute mise use -g "${pkg}@latest"
    else
        execute mise use -g "${pkg}@${version}"
    fi
}

# Verify package installation
verify_package() {
    local pkg="$1"
    
    if is_package_installed "${pkg}"; then
        local version
        version="$(get_package_version "${pkg}")"
        log_success "Package ${pkg} verified (${version})"
        return 0
    else
        log_error "Package ${pkg} verification failed"
        return 1
    fi
}

# Install multiple packages
install_packages() {
    local packages=("$@")
    local failed=0
    
    for pkg in "${packages[@]}"; do
        if ! install_package "${pkg}"; then
            log_error "Failed to install ${pkg}"
            ((failed++))
        fi
    done
    
    if [ ${failed} -gt 0 ]; then
        log_warning "${failed} package(s) failed to install"
        return 1
    fi
    
    log_success "All packages installed successfully"
    return 0
}
